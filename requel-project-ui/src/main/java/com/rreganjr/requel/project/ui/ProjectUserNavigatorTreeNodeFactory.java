/*
 * $Id$
 * Copyright 2008, 2009 Ron Regan Jr. All Rights Reserved.
 * This file is part of Requel - the Collaborative Requirements
 * Elicitation System.
 *
 * Requel is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Requel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Requel. If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.rreganjr.requel.project.ui;

import java.util.Enumeration;

import nextapp.echo2.app.Label;
import nextapp.echo2.app.event.ActionEvent;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import echopointng.tree.MutableTreeNode;
import echopointng.tree.TreePath;
import com.rreganjr.requel.project.Project;
import com.rreganjr.requel.project.ProjectOrDomainEntity;
import com.rreganjr.requel.project.ProjectUserRole;
import com.rreganjr.requel.user.User;
import net.sf.echopm.navigation.WorkflowDisposition;
import net.sf.echopm.navigation.event.EventDispatcher;
import net.sf.echopm.navigation.event.NavigationEvent;
import net.sf.echopm.navigation.event.OpenPanelEvent;
import net.sf.echopm.navigation.event.UpdateEntityEvent;
import net.sf.echopm.navigation.tree.AbstractNavigatorTreeNodeFactory;
import net.sf.echopm.navigation.tree.AbstractNavigatorTreeNodeUpdateListener;
import net.sf.echopm.navigation.tree.NavigatorTree;
import net.sf.echopm.navigation.tree.NavigatorTreeNode;
import net.sf.echopm.navigation.tree.NavigatorTreeNodeFactory;
import net.sf.echopm.panel.PanelActionType;

/**
 * @author ron
 */
@Component("projectUserNavigatorTreeNodeFactory")
@Scope("singleton")
public class ProjectUserNavigatorTreeNodeFactory extends AbstractNavigatorTreeNodeFactory {

	/**
	 * The property name to use to control the label on the project node
	 * generated by the factory.
	 */
	public final static String PROP_PROJECTS_NODE_LABEL = "ProjectsNodeLabel";

	/**
	 *
	 */
	public ProjectUserNavigatorTreeNodeFactory() {
		super(ProjectUserNavigatorTreeNodeFactory.class.getName(), User.class);
	}

	/**
	 * @see net.sf.echopm.navigation.tree.NavigatorTreeNodeFactory#createTreeNode(EventDispatcher, NavigatorTree, Object)
	 */
	public MutableTreeNode createTreeNode(EventDispatcher eventDispatcher, NavigatorTree tree,
			Object object) {
		User user = (User) object;
		ProjectUserRole projectUserRole = user.getRoleForType(ProjectUserRole.class);

		String projectsNodeLabel = getResourceBundleHelper(tree.getLocale()).getString(
				PROP_PROJECTS_NODE_LABEL, "Projects");

		NavigationEvent openProjectListEvent = new OpenPanelEvent(tree, PanelActionType.Navigator,
				user, ProjectUserRole.class, "projectList", WorkflowDisposition.NewFlow);

		NavigatorTreeNode projectsTreeNode = new NavigatorTreeNode(eventDispatcher,
				projectUserRole, new Label(projectsNodeLabel), openProjectListEvent);

		projectsTreeNode.setUpdateListener(new NavigatorTreeNodeProjectUpdateListener(
				projectsTreeNode, tree));

		for (Project project : projectUserRole.getActiveProjects()) {
			NavigatorTreeNodeFactory factory = tree.getNavigatorTreeNodeFactory(project);
			projectsTreeNode.add(factory.createTreeNode(eventDispatcher, tree, project));
		}
		return projectsTreeNode;
	}

	// TODO: this can be adapted for both Projects and Domains
	private static class NavigatorTreeNodeProjectUpdateListener extends
			AbstractNavigatorTreeNodeUpdateListener {
		static final long serialVersionUID = 0L;

		protected NavigatorTreeNodeProjectUpdateListener(NavigatorTreeNode navigatorTreeNode,
				NavigatorTree tree) {
			super(navigatorTreeNode, tree);
		}

		public void actionPerformed(ActionEvent event) {
			if (event instanceof UpdateEntityEvent) {
				UpdateEntityEvent updateEvent = (UpdateEntityEvent) event;
				if ((updateEvent.getObject() != null)) {
					Project updatedProject = null;
					if (updateEvent.getObject() instanceof Project) {
						updatedProject = (Project) updateEvent.getObject();
					} else if (updateEvent.getObject() instanceof ProjectOrDomainEntity) {
						ProjectOrDomainEntity updatedStakeholder = (ProjectOrDomainEntity) updateEvent
								.getObject();
						updatedProject = (Project) updatedStakeholder.getProjectOrDomain();
					}
					if (updatedProject != null) {
						NavigatorTreeNode projectsNode = getNavigatorTreeNode();
						// if there are no projects this is needed so the tree
						// will be redrawn
						if (projectsNode.isLeaf()) {
							getTree().getModel().nodeChanged(projectsNode);
						}
						MutableTreeNode projectNode = findProjectNode(projectsNode, updatedProject);
						if (projectNode != null) {
							getTree().getModel().removeNodeFromParent(projectNode);
							if (projectNode instanceof NavigatorTreeNode) {
								((NavigatorTreeNode) projectNode).dispose();
							}
						}
						addNode(projectsNode, updatedProject);
						getTree().expandPath(new TreePath(projectsNode.getPath()));
					}
				}
			}
		}

		private MutableTreeNode findProjectNode(MutableTreeNode projectsNode, Project project) {
			Enumeration<MutableTreeNode> enm = projectsNode.children();
			while (enm.hasMoreElements()) {
				MutableTreeNode node = enm.nextElement();
				if (node instanceof NavigatorTreeNode) {
					Object targetObject = ((NavigatorTreeNode) node).getTargetObject();
					if ((targetObject != null) && (targetObject instanceof Project)) {
						Project thisProject = (Project) targetObject;
						if (project.equals(thisProject)) {
							return node;
						}
					}
				}
			}
			return null;
		}

		private void addNode(MutableTreeNode projectsNode, Project project) {
			// add a new node for this user
			int indexToInsert = 0;
			Enumeration<MutableTreeNode> enm = projectsNode.children();
			while (enm.hasMoreElements()) {
				MutableTreeNode node = enm.nextElement();
				if (node instanceof NavigatorTreeNode) {
					Object targetObject = ((NavigatorTreeNode) node).getTargetObject();
					if ((targetObject != null) && (targetObject instanceof Project)) {
						Project thisProject = (Project) targetObject;
						if (project.compareTo(thisProject) < 1) {
							break;
						}
						indexToInsert++;
					}
				}
			}
			// see http://echo.nextapp.com/site/node/1625
			getTree().getModel().insertNodeInto(
					getTree().getNavigatorTreeNodeFactory(project).createTreeNode(
							getNavigatorTreeNode().getEventDispatcher(), getTree(), project),
					projectsNode, indexToInsert);

		}
	}
}
