/*
 * $Id$
 * Copyright 2008, 2009 Ron Regan Jr. All Rights Reserved.
 * This file is part of Requel - the Collaborative Requirements
 * Elicitation System.
 *
 * Requel is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Requel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Requel. If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.rreganjr.requel.ui.user;

import java.util.Enumeration;

import nextapp.echo2.app.Label;
import nextapp.echo2.app.event.ActionEvent;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import echopointng.tree.MutableTreeNode;
import com.rreganjr.requel.user.User;
import com.rreganjr.requel.user.UserSet;
import net.sf.echopm.navigation.WorkflowDisposition;
import net.sf.echopm.navigation.event.EventDispatcher;
import net.sf.echopm.navigation.event.NavigationEvent;
import net.sf.echopm.navigation.event.OpenPanelEvent;
import net.sf.echopm.navigation.event.UpdateEntityEvent;
import net.sf.echopm.navigation.tree.AbstractNavigatorTreeNodeFactory;
import net.sf.echopm.navigation.tree.AbstractNavigatorTreeNodeUpdateListener;
import net.sf.echopm.navigation.tree.NavigatorTree;
import net.sf.echopm.navigation.tree.NavigatorTreeNode;
import net.sf.echopm.navigation.tree.NavigatorTreeNodeFactory;
import net.sf.echopm.panel.PanelActionType;

/**
 * @author ron
 */
@Component("userCollectionNavigatorTreeNodeFactory")
@Scope("singleton")
public class UserCollectionNavigatorTreeNodeFactory extends AbstractNavigatorTreeNodeFactory {

	/**
	 * The property name to use to control the label on the primary node
	 * generated by the factory.
	 */
	public final static String PROP_USERS_NODE_LABEL = "UsersNodeLabel";

	/**
	 * @param eventDispatcher
	 */
	public UserCollectionNavigatorTreeNodeFactory() {
		super(UserCollectionNavigatorTreeNodeFactory.class.getName(), UserSet.class);
	}

	/**
	 * @see net.sf.echopm.navigation.tree.NavigatorTreeNodeFactory#createTreeNode(net.sf.echopm.navigation.tree.NavigatorTree,
	 *      java.lang.Object)
	 */
	public MutableTreeNode createTreeNode(EventDispatcher eventDispatcher, NavigatorTree tree,
			Object object) {
		UserSet users = (UserSet) object;
		String usersNodeLabel = getResourceBundleHelper(tree.getLocale()).getString(
				PROP_USERS_NODE_LABEL, "Users");

		// TODO: fire an event to a controller that reloads the
		// users and then fires an open panel event? or have the
		// NavigatorTreeNodeUpdateListener reset the event when
		// users are updated
		NavigationEvent openUserList = new OpenPanelEvent(tree, PanelActionType.Navigator, users,
				UserSet.class, null, WorkflowDisposition.NewFlow);

		NavigatorTreeNode usersTreeNode = new NavigatorTreeNode(eventDispatcher, users, new Label(
				usersNodeLabel), openUserList);

		usersTreeNode
				.setUpdateListener(new NavigatorTreeNodeUserUpdateListener(usersTreeNode, tree));

		// TODO: if there are lots of users, create a nested tree with
		// intermediate nodes representing the starting letters of user names
		// such that a node has no more than N nodes and no nodes are empty.
		for (User user : users) {
			NavigatorTreeNodeFactory factory = tree.getNavigatorTreeNodeFactory(user);
			usersTreeNode.add(factory.createTreeNode(eventDispatcher, tree, user));
		}
		return usersTreeNode;
	}

	private static class NavigatorTreeNodeUserUpdateListener extends
			AbstractNavigatorTreeNodeUpdateListener {
		static final long serialVersionUID = 0L;

		protected NavigatorTreeNodeUserUpdateListener(NavigatorTreeNode navigatorTreeNode,
				NavigatorTree tree) {
			super(navigatorTreeNode, tree);
		}

		public void actionPerformed(ActionEvent event) {
			if (event instanceof UpdateEntityEvent) {
				UpdateEntityEvent uee = (UpdateEntityEvent) event;
				if ((uee.getObject() != null) && (uee.getObject() instanceof User)) {
					User user = (User) uee.getObject();
					NavigatorTreeNode thisNode = getNavigatorTreeNode();
					UserSet users = (UserSet) thisNode.getTargetObject();
					if (!users.contains(user)) {
						addUserNode(thisNode, user);
					} else {
						removeUserNode(thisNode, user);
						addUserNode(thisNode, user);
					}
					users.add(user);
				}
			}
		}

		private void addUserNode(MutableTreeNode thisNode, User user) {
			// add a new node for this user
			int indexToInsert = 0;
			Enumeration<MutableTreeNode> enm = thisNode.children();
			while (enm.hasMoreElements()) {
				MutableTreeNode node = enm.nextElement();
				if (node instanceof NavigatorTreeNode) {
					Object targetObject = ((NavigatorTreeNode) node).getTargetObject();
					if ((targetObject != null) && (targetObject instanceof User)) {
						User nodeUser = (User) targetObject;
						if (User.UserComparator.compare(user, nodeUser) < 1) {
							break;
						}
						indexToInsert++;
					}
				}
			}
			// see http://echo.nextapp.com/site/node/1625
			getTree().getModel().insertNodeInto(
					getTree().getNavigatorTreeNodeFactory(user).createTreeNode(
							getNavigatorTreeNode().getEventDispatcher(), getTree(), user),
					thisNode, indexToInsert);

		}

		private void removeUserNode(MutableTreeNode thisNode, User user) {
			// remove the node with the user.
			Enumeration<MutableTreeNode> enm = thisNode.children();
			while (enm.hasMoreElements()) {
				MutableTreeNode node = enm.nextElement();
				if (node instanceof NavigatorTreeNode) {
					NavigatorTreeNode ntn = (NavigatorTreeNode) node;
					Object targetObject = ntn.getTargetObject();
					if ((targetObject != null) && (targetObject instanceof User)) {
						User nodeUser = (User) targetObject;
						if (User.UserComparator.compare(user, nodeUser) == 0) {
							getTree().getModel().removeNodeFromParent(node);
							break;
						}
					}
				}
			}
		}
	}
}
