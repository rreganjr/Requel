/*
 * $Id$
 * Copyright 2008, 2009 Ron Regan Jr. All Rights Reserved.
 * This file is part of Requel - the Collaborative Requirements
 * Elicitation System.
 *
 * Requel is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Requel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Requel. If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.rreganjr.nlp.dictionary;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import com.rreganjr.nlp.PartOfSpeech;
import com.rreganjr.nlp.dictionary.impl.repository.NoSuchWordException;
import com.rreganjr.nlp.dictionary.impl.repository.init.WordNetDefinitionWordsInitializer;
import com.rreganjr.nlp.dictionary.impl.repository.init.WordNetHyponymCountInitializer;
import com.rreganjr.repository.Repository;

/**
 * @author ron
 */
public interface DictionaryRepository extends Repository {

	/**
	 * @return The full dictonary of wordnet synsets, categories, and words.
	 */
	public Dictionary getDictionary();

	/**
	 * @param firstWordStartsWith
	 * @param lastWordStartsWith
	 * @return The words in the dictionary starting with the first word that
	 *         matches firstWordStartsWith and ending with the last word that
	 *         matches lastWordStartsWith
	 */
	public Dictionary getDictionary(String firstWordStartsWith, String lastWordStartsWith);

	/**
	 * The category name is looked up by prepending the partOfSpeech to the
	 * category name to get a category name of the form pos.catname, such as
	 * noun.location.
	 * 
	 * @param partOfSpeech
	 * @param name -
	 *            the simple category name without the leading part of speech,
	 *            for example 'location' and not 'noun.location'
	 * @return the category by part of speech and name
	 * @throws RuntimeException
	 */
	public Category findCategory(PartOfSpeech partOfSpeech, String name);

	/**
	 * @param id
	 * @return
	 */
	public Word findWord(Long id);

	/**
	 * @param lemma -
	 *            base form of the word.
	 * @return a word with associated senses/synsets for the given lemma
	 * @throws NoSuchWordException
	 */
	public Word findWord(String lemma) throws NoSuchWordException;

	/**
	 * @param lemma
	 * @return
	 * @throws NoSuchWordException
	 */
	public Word findWordExact(String lemma) throws NoSuchWordException;

	/**
	 * @param lemma -
	 *            base form of the word.
	 * @param pos -
	 *            part of speech
	 * @return a word with associated senses/synsets for the given lemma and
	 *         part of speech
	 * @throws NoSuchWordException
	 */
	public Word findWord(String lemma, PartOfSpeech pos) throws NoSuchWordException;

	/**
	 * @param lemma -
	 *            base form of the word.
	 * @param pos -
	 *            part of speech
	 * @return a word with associated senses/synsets for the given lemma and
	 *         part of speech
	 * @throws NoSuchWordException
	 */
	public Word findWordExact(String lemma, PartOfSpeech pos) throws NoSuchWordException;

	/**
	 * Generate a phonetic code using the Jazzy
	 * com.swabunga.spell.engine.DoubleMeta Transformator.
	 * 
	 * @param word
	 * @return
	 */
	public String generatePhoneticCode(String word);

	/**
	 * @param phoneticCode -
	 *            a code generated by the
	 * @return a word with associated senses/synsets for the given lemma
	 * @throws NoSuchWordException
	 */
	public List<Word> findWordsByPhoneticCode(String phoneticCode) throws NoSuchWordException;

	/**
	 * @param word
	 * @return true if the supplied word is in the dictionary
	 */
	public Boolean isKnownWord(String word);

	/**
	 * @param word
	 * @param threshold
	 * @return a list of words as Strings that are similar to the supplied word
	 *         with the given threshold.
	 */
	public List<String> findSpellingSuggestions(String word, int threshold);

	/**
	 * @param word
	 * @param maxSuggestions
	 * @return a list of word Senses that are a more specific (hyponyms) of the
	 *         supplied word with the highest information content.
	 */
	public Set<Sense> findMoreSpecificWords(Sense word, int maxSuggestions);

	/**
	 * Calculate the information content of a synset using the measure of Seco,
	 * Veale and Hayes, which uses the number of sub-terms (hyponyms) to
	 * determine how specific a term is. All synsets with no hyponyms are
	 * considered most specific and given a IC rank of 1.0. An artificial root
	 * node for all synsets of the same part of speech is assumed to better
	 * scale the information content of the lowest common subsumers, especially
	 * in the verb hierarchies which tend to be shallow and disjoint.
	 * 
	 * @param synset
	 * @param linkType
	 * @return
	 */
	public double infoContent(Synset synset, Linkdef linkType);

	/**
	 * TODO: the repository should be for getting only, this should be part of a
	 * command.
	 * 
	 * @param word
	 */
	public void addToDictionary(String word);

	/**
	 * @return all the words in the dictionary
	 * @throws RuntimeException
	 */
	public Collection<Word> findWords();

	/**
	 * @return all the Synset categories in the dictionary
	 * @throws RuntimeException
	 */
	public Collection<Category> findCategories();

	/**
	 * @return all the Synsets in the dictionary.
	 * @throws RuntimeException
	 */
	public Collection<Synset> findSynsets();

	/**
	 * @return all the Senses in the dictionary.
	 */
	public Collection<Sense> findSenses();

	/**
	 * @param lemma
	 * @param pos
	 * @param senseIndex
	 * @return A synset
	 */
	public Sense findSense(String lemma, PartOfSpeech pos, int senseIndex);

	/**
	 * a WordNet sense key is a composite made up of:<br>
	 * lemma % ss_type:lex_filenum:lex_id:head_word:head_id The ss_type (synset
	 * type) is a digit:<br>
	 * 1 - NOUN<br>
	 * 2 - VERB<br>
	 * 3 - ADJECTIVE<br>
	 * 4 - ADVERB<br>
	 * 5 - ADJECTIVE SATELLITE<br>
	 * The lex_filenum is a two digit number identifying the lexicographer file
	 * containing the synset.<br>
	 * The lex_id is a two digit number that uniquely identifies a sense.<br>
	 * The head_word is the lemma of the first word of an adjective satellite
	 * synset.<br>
	 * The head_id is the lex_id of the head_word.<br>
	 * 
	 * @param senseKey -
	 *            the sense key (is this really for a synset?)
	 * @return a sense by the wornet sense key and word
	 */
	public Sense findSensesByWordnetSenseKey(String senseKey);

	/**
	 * @param word
	 * @param synset
	 * @return
	 */
	public Sense findSensesByWordAndSynset(Word word, Synset synset);

	/**
	 * @param lemma
	 * @param synsetId
	 * @return
	 */
	public Sense findSensesByLemmaAndSynsetId(String lemma, Long synsetId);

	/**
	 * @param id
	 * @return Get a specific synset by id
	 */
	public Synset findSynset(Long id);

	/**
	 * @param id
	 * @return Get a specific semantic link definition by id
	 */
	public Linkdef findLinkDef(Long id);

	/**
	 * @param id
	 * @return Get a semantic link by id.
	 */
	public Semlinkref findSemlinkref(SemlinkrefId id);

	/**
	 * @param fromSynset
	 * @param toSynset
	 * @param linkDef
	 * @param distance
	 * @return Get a Semantic path between two synsets by type and distance.
	 */
	public Semlinkref findSemlinkref(Synset fromSynset, Synset toSynset, Linkdef linkDef,
			Integer distance);

	/**
	 * @param id
	 * @return Get a lexo-semantic link by id.
	 */
	public Lexlinkref findLexlinkref(LexlinkrefId id);

	/**
	 * @param fromSense
	 * @param toSense
	 * @param linkDef
	 * @return Get a lexo-semantic link between two words
	 */
	public Lexlinkref findLexlinkref(Sense fromSense, Sense toSense, Linkdef linkDef);

	/**
	 * @param fromSense
	 * @param toSense
	 * @return a collection of all the lexo-semantic relations between two
	 *         senses.
	 */
	public Collection<Lexlinkref> findLexlinkref(Sense fromSense, Sense toSense);

	/**
	 * @return true if the synset wsd data needs to be expanded during
	 *         initialization
	 * @see WordNetDefinitionWordsInitializer
	 */
	public boolean buildSynsetDefinitionWords();

	/**
	 * @return true if the synset wsd data needs to be expanded during
	 *         initialization
	 * @see WordNetHyponymCountInitializer
	 */
	public boolean buildSynsetLinkPathsAndCounts();

	/**
	 * @return true if the wordnet senses don't have SenseKey's defined.
	 */
	public boolean buildSenseKeys();

	/**
	 * This is used by the WordNetHyponymCountInitializer to get all the
	 * semantic links from the semlinkref table. Note these are returned as
	 * 4-tuples of the properties and not Semlinkref objects for faster
	 * processing.
	 * 
	 * @return a List of (from synset, to synset, link type, distance) tuples
	 */
	public List<Object[]> findSemanticLinks();

	/**
	 * @return All the semantic link types
	 */
	public Collection<Linkdef> findLinkdefs();

	/**
	 * @param synset1
	 * @param synset2
	 * @return The set of synsets that are hypernyms or the supplied synsets
	 *         having the shortest path between the two synsets. This will
	 *         typically return a set of one synset, although synsets may have
	 *         multiple ancestors and it is possible for multiple ancestors to
	 *         have the same path distance between the synsets, in which case
	 *         all those synsets will be returned. If the two synsets do not
	 *         have a common ancestor (for example a noun and a verb), then an
	 *         empty set is returned.
	 */
	public Set<Synset> getLowestCommonHypernyms(Synset synset1, Synset synset2);

	/**
	 * Wordnet is made up of multiple disjoint hierarchies of synsets. This
	 * returns the root node of those hierarchies.
	 * 
	 * @param synset
	 * @return The synset that is a hypernym of the supplied synset and has no
	 *         hypernyms.
	 */
	public Synset getRootHypernym(Synset synset);

	/**
	 * @param pos
	 * @return The number of concepts (synsets) of the given part of speech.
	 */
	public Integer getConceptCount(String pos);

	/**
	 * @param word1
	 * @param word2
	 * @return a list of the synsets that contain both supplied words of any
	 *         sense in their definition.
	 */
	public List<Synset> findSynsetsWithColocatedDefinitionWords(Word word1, Word word2);

	/**
	 * @param sense
	 * @param word
	 * @return a list of the synsets that contain both the supplied word sense
	 *         and un-sensed word.
	 */
	public List<Synset> findSynsetsWithColocatedDefinitionSenseAndWord(Sense sense, Word word);

	/**
	 * @return all the Semcor files in the dictionary.
	 */
	public Collection<SemcorFile> findSemcorFiles();

	/**
	 * @param sectionName
	 * @param fileName
	 * @return all the Semcor files in the dictionary.
	 */
	public SemcorFile findSemcorFile(String sectionName, String fileName);

	/**
	 * @return all the Semcor sentences in the dictionary.
	 */
	public Collection<SemcorSentence> findSemcorSentences();

	/**
	 * @param sectionName
	 * @param fileName
	 * @return all the Semcor sentences in the given section and file.
	 */
	public Collection<SemcorSentence> findSemcorSentences(String sectionName, String fileName);

	/**
	 * Find semcor sentences that contain the supplied word
	 * 
	 * @param word -
	 *            a dictionary word of any sense
	 * @return
	 */
	public Collection<SemcorSentence> findSemcorSentences(Word word);

	/**
	 * Find semcor sentences that contain the supplied word sense
	 * 
	 * @param sense -
	 *            a specific sense of the word
	 * @return
	 */
	public Collection<SemcorSentence> findSemcorSentences(Sense sense);

	/**
	 * @param word1
	 * @param word2
	 * @return a list of the semcor sentences that contain both supplied words
	 *         of any sense in their definition.
	 */
	public List<SemcorSentenceWord> findSemcorSentencesWithColocatedDefinitionWords(Word word1,
			Word word2);

	/**
	 * @param sense
	 * @param word
	 * @return a list of the semcor sentences that contain both the supplied
	 *         word sense and un-sensed word.
	 */
	public List<SemcorSentenceWord> findSemcorSentencesWithColocatedDefinitionSenseAndWord(
			Sense sense, Word word);

	/**
	 * @param name -
	 *            the name of the selectional restriction based on verbnet-2.1
	 *            vn_schema-3.xsd selrestrType type.
	 * @return a selectional restriction for the given name
	 */
	public VerbNetSelectionRestrictionType findVerbNetSelectionRestrictionType(String name);

	/**
	 * This is a convenience method for comparing the synsets of two senses.
	 * 
	 * @param hypernym -
	 *            a sense represening the hypernym
	 * @param sense
	 * @return true if the supplied sense is a hyponym of the supplied hypernym
	 *         sense.
	 * @see {@link #isHyponym(Synset, Synset)}
	 */
	public boolean isHyponym(Sense hypernym, Sense sense);

	/**
	 * @param hypernym -
	 *            a synset that may be the hypernym of the supplied synset
	 * @param synset -
	 *            the synset to test
	 * @return true if the supplied synset is a hyponym of the supplied hypernym
	 *         synset.
	 */
	public boolean isHyponym(Synset hypernym, Synset synset);

	/**
	 * @param hypernym -
	 *            The synset that is the hypernym of the returned hyponyms
	 * @return The hypernyms of the supplied hypernym where the distince between
	 * @param maxDistance -
	 *            The maximum distance from the specified hypernym to the
	 *            hyponyms. Where the direct hyponyms are at a distance of 1 and
	 *            the hyponyms of of the direct hyponyms are at a distance of 2
	 *            etc. the synsets is less than or equal to the maxDepth.
	 */
	public Collection<Synset> findHyponyms(Synset hypernym, int maxDistance);
}
